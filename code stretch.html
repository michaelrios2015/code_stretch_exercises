<html>
  <head> </head>
  <body>
    <script>


//TODO


const randomList = (arr, num) => {

  let newArr = [];

//looping through array to  create a sub array 
  for (let i=0; i<num; i++){
 
  let x = Math.floor(Math.random() * arr.length);
  //allows us to pick array eleemnts randomly and not repeat them
  while (newArr.includes(arr[x])){
  x = Math.floor(Math.random() * arr.length);
  //console.log("x = " + x);   
  }
  
  newArr.push(arr[x]);
  
  //console.log("out");
  //newArr.push(arr[x]);

}

return newArr;
}

console.log("----------randomList----------")
console.log(randomList([1, 2, 3], 2));//[1, 2] or [2, 1] or [1, 3] etc.
console.log(randomList(['foo', 'bar', 'bazz', 'quq'], 2));//a random choice of 2 out of 4, with no repeats


//sunday 10/18/20

//TODO

// const fill = (length, value) =>{

// let arr =[];

// for (let i=0; i<length; i++){

// if (typeof value === 'object'){
//   let newVal = Object.assign({}, value);
//  arr.push(newVal);
// } else { 
//   arr.push(value);
// }
// }

// return arr;

// }


// const a1 = fill(3, true);
// console.log(a1);//[true, true, true];
// const a2 = fill(4, 42);
// console.log(a2);//[42, 42, 42, 42];

// const x = {foo: 'bar'};
// const a3 = fill(2, x);
// console.log(a3);//[ { foo: 'bar' }, { foo: 'bar' } ]
// console.log(a3[0] === a3[1]);//false


//TODO

const multString = (nums) => {

let arr = nums.split(',');

//this reduce statement is the same as the for loop below
return arr.reduce((accumulator, currentValue) => accumulator * currentValue);


// let total = 1;
// for (let i = 0; i<arr.length; i++){
//   total = total * arr[i];
// }

console.log(arr);


}

console.log("----------multiString----------")
console.log(multString('2, 5, 3'));//30
console.log(multString('2, 2, 2'));//8


//TODO

const uniqueConsonant = (str) =>{

//console.log(str.split(''));

//logic for filtering out vowels is pretty easy
//to get rid of duplicat comsonants is a little harder see emoveDuplicates below 
return str.split('').filter(function(letter, index){ if (letter !='a' && letter !='e' && letter !='i' && letter !='o' && letter !='u'&& str.indexOf(letter) === index)
 {return letter}}); 

}


console.log("----------uniqueConsonant----------")
console.log(uniqueConsonant('abacub'));//[ 'b', 'c' ]


// var arr = ["banana", "apple", "orange", "lemon", "apple", "lemon"];

// function removeDuplicates(data){

//   return data.filter(function(value, index){
//     console.log(index);
//     console.log("indexOf");
//     //this is the first instance of the value, so later instances have a different index
//     //and we can ignore those.  tricky because I had never see indexOf before but makes
//     //sense now :)  
//     console.log(data.indexOf(value));
//    if (data.indexOf(value)  === index)
//    {return value;}
//    });

// } 

// console.log(removeDuplicates(arr));



//TODO

const isMatch = (objOne, objTwo) => {

//I think this is a round about way of doing it and only works if the objects 
//are lined up but it in this case they were 

//turned both objects into flattened arrays
const arrOne = Object.entries(objOne).flat();
const arrTwo = Object.entries(objTwo).flat();

let length = 0;

//we want the smaller length
if (arrOne.length > arrTwo.length){
  length = arrTwo.length;
} else {
  length = arrOne.length;
}

//one is an empty object supposed to be false 
if (length === 0){
  return false;
}

//loop through both objects and compare vulues this part is easy,
//but what if the values were not in the same order.. 
for (let i = 0; i<length; i++ ){
  if (arrOne[i] != arrTwo[i]){
    return false;
  }
}

//console.log(arrOne);
return true;
}



console.log("----------isMatch----------")
console.log(isMatch({}, {x: 1}));//false
console.log(isMatch({x: 1, y: 2}, {x: 1}));//true
console.log(isMatch({x: 1, y: 2, z: 3}, {x: 1, y: 2}));//true
console.log(isMatch({x: 1, y: 2, z: 3}, {x: 1, y: 1}));//false


    </script>
  </body>
</html>

